KASAN is supported on powerpc on 32-bit and Radix 64-bit only.

32 bit support
==============

KASAN is supported on both hash and nohash MMUs on 32-bit.

The shadow area sits at the top of the kernel virtual memory space above the
fixmap area and occupies one eighth of the total kernel virtual memory space.

Instrumentation of the vmalloc area is optional, unless built with modules,
in which case it is required.

64 bit support
==============

Currently, only the radix MMU is supported. There have been versions for Book3E
processors floating around on the mailing list, but nothing has been merged.

KASAN support on Book3S is a bit tricky to get right:

 - It would be good to support inline instrumentation so as to be able to catch
   stack issues that cannot be caught with outline mode.

 - Inline instrumentation requires a fixed offset.

 - Book3S runs code in real mode after booting. Most notably a lot of KVM runs
   in real mode, and it would be good to be able to instrument it.

 - Because code runs in real mode after boot, the offset has to point to
   valid memory both in and out of real mode.

One approach is just to give up on inline instrumentation. This way all checks
can be delayed until after everything set is up correctly, and the
address-to-shadow calculations can be overridden. However, the features and
speed boost provided by inline instrumentation are worth trying to do better.

If _at compile time_ it is known how much contiguous physical memory a system
has, the top 1/8th of the first block of physical memory can be set aside for
the shadow. This is a big hammer and comes with 3 big consequences:

 - there's no nice way to handle physically discontiguous memory, so only the
   first physical memory block can be used.

 - kernels will simply fail to boot on machines with less memory than specified
   when compiling.

 - kernels running on machines with more memory than specified when compiling
   will simply ignore the extra memory.

At the moment, this physical memory limit must be set _even for outline mode_.
This may be changed in a future version - a different implementation could be
added for outline mode that dynamically allocates shadow at a fixed offset.
For example, see https://patchwork.ozlabs.org/patch/795211/

This value is configured in CONFIG_PHYS_MEM_SIZE_FOR_KASAN.

Tips
----

 - Compile with CONFIG_RELOCATABLE.

   In development, boot hangs were observed when building with ftrace and KUAP
   on. These ended up being due to kernel bloat pushing prom_init calls to be
   done via the PLT. Because the kernel was not relocatable, and the calls are
   done very early, this caused execution to jump off into somewhere
   invalid. Enabling relocation fixes this.

NUMA/discontiguous physical memory
----------------------------------

Currently the code cannot really deal with discontiguous physical memory. Only
physical memory that is contiguous from physical address zero can be used. The
size of that memory, not total memory, must be specified when configuring the
kernel.

Discontiguous memory can occur on machines with memory spread across multiple
nodes. For example, on a Talos II with 64GB of RAM:

 - 32GB runs from 0x0 to 0x0000_0008_0000_0000,
 - then there's a gap,
 - then the final 32GB runs from 0x0000_2000_0000_0000 to 0x0000_2008_0000_0000

This can create _significant_ issues:

 - If the machine is treated as having 64GB of _contiguous_ RAM, the
   instrumentation would assume that it ran from 0x0 to
   0x0000_0010_0000_0000. The last 1/8th - 0x0000_000e_0000_0000 to
   0x0000_0010_0000_0000 would be reserved as the shadow region. But when the
   kernel tried to access any of that, it would be trying to access pages that
   are not physically present.

 - If the shadow region size is based on the top address, then the shadow
   region would be 0x2008_0000_0000 / 8 = 0x0401_0000_0000 bytes = 4100 GB of
   memory, clearly more than the 64GB of RAM physically present.

Therefore, the code currently is restricted to dealing with memory in the node
starting at 0x0. For this system, that's 32GB. If a contiguous physical memory
size greater than the size of the first contiguous region of memory is
specified, the system will be unable to boot or even print an error message.

The layout of a system's memory can be observed in the messages that the Radix
MMU prints on boot. The Talos II discussed earlier has:

radix-mmu: Mapped 0x0000000000000000-0x0000000040000000 with 1.00 GiB pages (exec)
radix-mmu: Mapped 0x0000000040000000-0x0000000800000000 with 1.00 GiB pages
radix-mmu: Mapped 0x0000200000000000-0x0000200800000000 with 1.00 GiB pages

As discussed, this system would be configured for 32768 MB.

Another system prints:

radix-mmu: Mapped 0x0000000000000000-0x0000000040000000 with 1.00 GiB pages (exec)
radix-mmu: Mapped 0x0000000040000000-0x0000002000000000 with 1.00 GiB pages
radix-mmu: Mapped 0x0000200000000000-0x0000202000000000 with 1.00 GiB pages

This machine has more memory: 0x0000_0040_0000_0000 total, but only
0x0000_0020_0000_0000 is physically contiguous from zero, so it would be
configured for 131072 MB of physically contiguous memory.

This restriction currently also affects outline mode, but this could be
changed in future if an alternative outline implementation is added.
