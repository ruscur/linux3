           Booting the Linux/ppc kernel without Open Firmware
           --------------------------------------------------

(c) 2005 Benjamin Herrenschmidt <benh at kernel.crashing.org>,
    IBM Corp.
(c) 2005 Becky Bruce <becky.bruce at freescale.com>,
    Freescale Semiconductor, FSL SOC and 32-bit additions
(c) 2006 MontaVista Software, Inc.
    Flash chip node definition

Table of Contents
=================

  I - Introduction
    1) Entry point for arch/arm
    2) Entry point for arch/powerpc
    3) Entry point for arch/x86
    4) Entry point for arch/mips/bmips
    5) Entry point for arch/sh

  II - The DT block format
    2) Device tree generalities

  III - Required content of the device tree
    1) Note about cells and address representation
    5) Required nodes and properties
      a) The root node

  VIII - Specifying device power management information (sleep property)

  IX - Specifying dma bus information


Revision Information
====================

   May 18, 2005: Rev 0.1 - Initial draft, no chapter III yet.

   May 19, 2005: Rev 0.2 - Add chapter III and bits & pieces here or
                           clarifies the fact that a lot of things are
                           optional, the kernel only requires a very
                           small device tree, though it is encouraged
                           to provide an as complete one as possible.

   May 24, 2005: Rev 0.3 - Precise that DT block has to be in RAM
			 - Misc fixes
			 - Define version 3 and new format version 16
			   for the DT block (version 16 needs kernel
			   patches, will be fwd separately).
			   String block now has a size, and full path
			   is replaced by unit name for more
			   compactness.
			   linux,phandle is made optional, only nodes
			   that are referenced by other nodes need it.
			   "name" property is now automatically
			   deduced from the unit name

   June 1, 2005: Rev 0.4 - Correct confusion between OF_DT_END and
                           OF_DT_END_NODE in structure definition.
                         - Change version 16 format to always align
                           property data to 4 bytes. Since tokens are
                           already aligned, that means no specific
                           required alignment between property size
                           and property data. The old style variable
                           alignment would make it impossible to do
                           "simple" insertion of properties using
                           memmove (thanks Milton for
                           noticing). Updated kernel patch as well
			 - Correct a few more alignment constraints
			 - Add a chapter about the device-tree
                           compiler and the textural representation of
                           the tree that can be "compiled" by dtc.

   November 21, 2005: Rev 0.5
			 - Additions/generalizations for 32-bit
			 - Changed to reflect the new arch/powerpc
			   structure
			 - Added chapter VI


I - Introduction
================

During the development of the Linux/ppc64 kernel, and more
specifically, the addition of new platform types outside of the old
IBM pSeries/iSeries pair, it was decided to enforce some strict rules
regarding the kernel entry and bootloader <-> kernel interfaces, in
order to avoid the degeneration that had become the ppc32 kernel entry
point and the way a new platform should be added to the kernel. The
legacy iSeries platform breaks those rules as it predates this scheme,
but no new board support will be accepted in the main tree that
doesn't follow them properly.  In addition, since the advent of the
arch/powerpc merged architecture for ppc32 and ppc64, new 32-bit
platforms and 32-bit platforms which move into arch/powerpc will be
required to use these rules as well.

The main requirement that will be defined in more detail below is
the presence of a device-tree whose format is defined after Open
Firmware specification. However, in order to make life easier
to embedded board vendors, the kernel doesn't require the device-tree
to represent every device in the system and only requires some nodes
and properties to be present. This will be described in detail in
section III, but, for example, the kernel does not require you to
create a node for every PCI device in the system. It is a requirement
to have a node for PCI host bridges in order to provide interrupt
routing information and memory/IO ranges, among others. It is also
recommended to define nodes for on chip devices and other buses that
don't specifically fit in an existing OF specification. This creates a
great flexibility in the way the kernel can then probe those and match
drivers to device, without having to hard code all sorts of tables. It
also makes it more flexible for board vendors to do minor hardware
upgrades without significantly impacting the kernel code or cluttering
it with special cases.


1) Entry point for arch/arm
---------------------------

   There is one single entry point to the kernel, at the start
   of the kernel image. That entry point supports two calling
   conventions.  A summary of the interface is described here.  A full
   description of the boot requirements is documented in
   Documentation/arm/booting.rst

        a) ATAGS interface.  Minimal information is passed from firmware
        to the kernel with a tagged list of predefined parameters.

                r0 : 0

                r1 : Machine type number

                r2 : Physical address of tagged list in system RAM

        b) Entry with a flattened device-tree block.  Firmware loads the
        physical address of the flattened device tree block (dtb) into r2,
        r1 is not used, but it is considered good practice to use a valid
        machine number as described in Documentation/arm/booting.rst.

                r0 : 0

                r1 : Valid machine type number.  When using a device tree,
                a single machine type number will often be assigned to
                represent a class or family of SoCs.

                r2 : physical pointer to the device-tree block
                (defined in chapter II) in RAM.  Device tree can be located
                anywhere in system RAM, but it should be aligned on a 64 bit
                boundary.

   The kernel will differentiate between ATAGS and device tree booting by
   reading the memory pointed to by r2 and looking for either the flattened
   device tree block magic value (0xd00dfeed) or the ATAG_CORE value at
   offset 0x4 from r2 (0x54410001).

2) Entry point for arch/powerpc
-------------------------------

   There is one single entry point to the kernel, at the start
   of the kernel image. That entry point supports two calling
   conventions:

        a) Boot from Open Firmware. If your firmware is compatible
        with Open Firmware (IEEE 1275) or provides an OF compatible
        client interface API (support for "interpret" callback of
        forth words isn't required), you can enter the kernel with:

              r5 : OF callback pointer as defined by IEEE 1275
              bindings to powerpc. Only the 32-bit client interface
              is currently supported

              r3, r4 : address & length of an initrd if any or 0

              The MMU is either on or off; the kernel will run the
              trampoline located in arch/powerpc/kernel/prom_init.c to
              extract the device-tree and other information from open
              firmware and build a flattened device-tree as described
              in b). prom_init() will then re-enter the kernel using
              the second method. This trampoline code runs in the
              context of the firmware, which is supposed to handle all
              exceptions during that time.

        b) Direct entry with a flattened device-tree block. This entry
        point is called by a) after the OF trampoline and can also be
        called directly by a bootloader that does not support the Open
        Firmware client interface. It is also used by "kexec" to
        implement "hot" booting of a new kernel from a previous
        running one. This method is what I will describe in more
        details in this document, as method a) is simply standard Open
        Firmware, and thus should be implemented according to the
        various standard documents defining it and its binding to the
        PowerPC platform. The entry point definition then becomes:

                r3 : physical pointer to the device-tree block
                (defined in chapter II) in RAM

                r4 : physical pointer to the kernel itself. This is
                used by the assembly code to properly disable the MMU
                in case you are entering the kernel with MMU enabled
                and a non-1:1 mapping.

                r5 : NULL (as to differentiate with method a)

        Note about SMP entry: Either your firmware puts your other
        CPUs in some sleep loop or spin loop in ROM where you can get
        them out via a soft reset or some other means, in which case
        you don't need to care, or you'll have to enter the kernel
        with all CPUs. The way to do that with method b) will be
        described in a later revision of this document.

   Board supports (platforms) are not exclusive config options. An
   arbitrary set of board supports can be built in a single kernel
   image. The kernel will "know" what set of functions to use for a
   given platform based on the content of the device-tree. Thus, you
   should:

        a) add your platform support as a _boolean_ option in
        arch/powerpc/Kconfig, following the example of PPC_PSERIES,
        PPC_PMAC and PPC_MAPLE. The later is probably a good
        example of a board support to start from.

        b) create your main platform file as
        "arch/powerpc/platforms/myplatform/myboard_setup.c" and add it
        to the Makefile under the condition of your CONFIG_
        option. This file will define a structure of type "ppc_md"
        containing the various callbacks that the generic code will
        use to get to your platform specific code

  A kernel image may support multiple platforms, but only if the
  platforms feature the same core architecture.  A single kernel build
  cannot support both configurations with Book E and configurations
  with classic Powerpc architectures.

3) Entry point for arch/x86
-------------------------------

  There is one single 32bit entry point to the kernel at code32_start,
  the decompressor (the real mode entry point goes to the same  32bit
  entry point once it switched into protected mode). That entry point
  supports one calling convention which is documented in
  Documentation/x86/boot.rst
  The physical pointer to the device-tree block (defined in chapter II)
  is passed via setup_data which requires at least boot protocol 2.09.
  The type filed is defined as

  #define SETUP_DTB                      2

  This device-tree is used as an extension to the "boot page". As such it
  does not parse / consider data which is already covered by the boot
  page. This includes memory size, reserved ranges, command line arguments
  or initrd address. It simply holds information which can not be retrieved
  otherwise like interrupt routing or a list of devices behind an I2C bus.

4) Entry point for arch/mips/bmips
----------------------------------

  Some bootloaders only support a single entry point, at the start of the
  kernel image.  Other bootloaders will jump to the ELF start address.
  Both schemes are supported; CONFIG_BOOT_RAW=y and CONFIG_NO_EXCEPT_FILL=y,
  so the first instruction immediately jumps to kernel_entry().

  Similar to the arch/arm case (b), a DT-aware bootloader is expected to
  set up the following registers:

         a0 : 0

         a1 : 0xffffffff

         a2 : Physical pointer to the device tree block (defined in chapter
         II) in RAM.  The device tree can be located anywhere in the first
         512MB of the physical address space (0x00000000 - 0x1fffffff),
         aligned on a 64 bit boundary.

  Legacy bootloaders do not use this convention, and they do not pass in a
  DT block.  In this case, Linux will look for a builtin DTB, selected via
  CONFIG_DT_*.

  This convention is defined for 32-bit systems only, as there are not
  currently any 64-bit BMIPS implementations.

5) Entry point for arch/sh
--------------------------

  Device-tree-compatible SH bootloaders are expected to provide the physical
  address of the device tree blob in r4. Since legacy bootloaders did not
  guarantee any particular initial register state, kernels built to
  inter-operate with old bootloaders must either use a builtin DTB or
  select a legacy board option (something other than CONFIG_SH_DEVICE_TREE)
  that does not use device tree. Support for the latter is being phased out
  in favor of device tree.


II - The DT block format
========================


Note: The block has to be in main memory. It has to be accessible in
both real mode and virtual mode with no mapping other than main
memory. If you are writing a simple flash bootloader, it should copy
the block to RAM before passing it to the kernel.




2) Device tree generalities
---------------------------

First, let's quickly describe the device-tree concept before detailing
the storage format. This chapter does _not_ describe the detail of the
required types of nodes & properties for the kernel, this is done
later in chapter III.

The device-tree layout is strongly inherited from the definition of
the Open Firmware IEEE 1275 device-tree. It's basically a tree of
nodes, each node having two or more named properties. A property can
have a value or not.

It is a tree, so each node has one and only one parent except for the
root node who has no parent.

A node has 2 names. The actual node name is generally contained in a
property of type "name" in the node property list whose value is a
zero terminated string and is mandatory for version 1 to 3 of the
format definition (as it is in Open Firmware). Version 16 makes it
optional as it can generate it from the unit name defined below.

There is also a "unit name" that is used to differentiate nodes with
the same name at the same level, it is usually made of the node
names, the "@" sign, and a "unit address", which definition is
specific to the bus type the node sits on.

The unit name doesn't exist as a property per-se but is included in
the device-tree structure. It is typically used to represent "path" in
the device-tree. More details about the actual format of these will be
below.

The kernel generic code does not make any formal use of the
unit address (though some board support code may do) so the only real
requirement here for the unit address is to ensure uniqueness of
the node unit name at a given level of the tree. Nodes with no notion
of address and no possible sibling of the same name (like /memory or
/cpus) may omit the unit address in the context of this specification,
or use the "@0" default unit address. The unit name is used to define
a node "full path", which is the concatenation of all parent node
unit names separated with "/".

The root node doesn't have a defined name, and isn't required to have
a name property either if you are using version 3 or earlier of the
format. It also has no unit address (no @ symbol followed by a unit
address). The root node unit name is thus an empty string. The full
path to the root node is "/".

Every node which actually represents an actual device (that is, a node
which isn't only a virtual "container" for more nodes, like "/cpus"
is) is also required to have a "compatible" property indicating the
specific hardware and an optional list of devices it is fully
backwards compatible with.


III - Required content of the device tree
=========================================

WARNING: All "linux,*" properties defined in this document apply only
to a flattened device-tree. If your platform uses a real
implementation of Open Firmware or an implementation compatible with
the Open Firmware client interface, those properties will be created
by the trampoline code in the kernel's prom_init() file. For example,
that's where you'll have to add code to detect your board model and
set the platform number. However, when using the flattened device-tree
entry point, there is no prom_init() pass, and thus you have to
provide those properties yourself.


1) Note about cells and address representation
----------------------------------------------

The general rule is documented in the various Open Firmware
documentations. If you choose to describe a bus with the device-tree
and there exist an OF bus binding, then you should follow the
specification. However, the kernel does not require every single
device or bus to be described by the device tree.

In general, the format of an address for a device is defined by the
parent bus type, based on the #address-cells and #size-cells
properties.  Note that the parent's parent definitions of #address-cells
and #size-cells are not inherited so every node with children must specify
them.  The kernel requires the root node to have those properties defining
addresses format for devices directly mapped on the processor bus.

Those 2 properties define 'cells' for representing an address and a
size. A "cell" is a 32-bit number. For example, if both contain 2
like the example tree given above, then an address and a size are both
composed of 2 cells, and each is a 64-bit number (cells are
concatenated and expected to be in big endian format). Another example
is the way Apple firmware defines them, with 2 cells for an address
and one cell for a size.  Most 32-bit implementations should define
#address-cells and #size-cells to 1, which represents a 32-bit value.
Some 32-bit processors allow for physical addresses greater than 32
bits; these processors should define #address-cells as 2.

"reg" properties are always a tuple of the type "address size" where
the number of cells of address and size is specified by the bus
#address-cells and #size-cells. When a bus supports various address
spaces and other flags relative to a given address allocation (like
prefetchable, etc...) those flags are usually added to the top level
bits of the physical address. For example, a PCI physical address is
made of 3 cells, the bottom two containing the actual address itself
while the top cell contains address space indication, flags, and pci
bus & device numbers.

For buses that support dynamic allocation, it's the accepted practice
to then not provide the address in "reg" (keep it 0) though while
providing a flag indicating the address is dynamically allocated, and
then, to provide a separate "assigned-addresses" property that
contains the fully allocated addresses. See the PCI OF bindings for
details.

In general, a simple bus with no address space bits and no dynamic
allocation is preferred if it reflects your hardware, as the existing
kernel address parsing functions will work out of the box. If you
define a bus type with a more complex address format, including things
like address space bits, you'll have to add a bus translator to the
prom_parse.c file of the recent kernels for your bus type.

The "reg" property only defines addresses and sizes (if #size-cells is
non-0) within a given bus. In order to translate addresses upward
(that is into parent bus addresses, and possibly into CPU physical
addresses), all buses must contain a "ranges" property. If the
"ranges" property is missing at a given level, it's assumed that
translation isn't possible, i.e., the registers are not visible on the
parent bus.  The format of the "ranges" property for a bus is a list
of:

	bus address, parent bus address, size

"bus address" is in the format of the bus this bus node is defining,
that is, for a PCI bridge, it would be a PCI address. Thus, (bus
address, size) defines a range of addresses for child devices. "parent
bus address" is in the format of the parent bus of this bus. For
example, for a PCI host controller, that would be a CPU address. For a
PCI<->ISA bridge, that would be a PCI address. It defines the base
address in the parent bus where the beginning of that range is mapped.

For new 64-bit board support, I recommend either the 2/2 format or
Apple's 2/1 format which is slightly more compact since sizes usually
fit in a single 32-bit word.   New 32-bit board support should use a
1/1 format, unless the processor supports physical addresses greater
than 32-bits, in which case a 2/1 format is recommended.

Alternatively, the "ranges" property may be empty, indicating that the
registers are visible on the parent bus using an identity mapping
translation.  In other words, the parent bus address space is the same
as the child bus address space.


5) Required nodes and properties
--------------------------------

  Additional properties for the root node:

    - serial-number : a string representing the device's serial number


VIII - Specifying Device Power Management Information (sleep property)
===================================================================

Devices on SOCs often have mechanisms for placing devices into low-power
states that are decoupled from the devices' own register blocks.  Sometimes,
this information is more complicated than a cell-index property can
reasonably describe.  Thus, each device controlled in such a manner
may contain a "sleep" property which describes these connections.

The sleep property consists of one or more sleep resources, each of
which consists of a phandle to a sleep controller, followed by a
controller-specific sleep specifier of zero or more cells.

The semantics of what type of low power modes are possible are defined
by the sleep controller.  Some examples of the types of low power modes
that may be supported are:

 - Dynamic: The device may be disabled or enabled at any time.
 - System Suspend: The device may request to be disabled or remain
   awake during system suspend, but will not be disabled until then.
 - Permanent: The device is disabled permanently (until the next hard
   reset).

Some devices may share a clock domain with each other, such that they should
only be suspended when none of the devices are in use.  Where reasonable,
such nodes should be placed on a virtual bus, where the bus has the sleep
property.  If the clock domain is shared among devices that cannot be
reasonably grouped in this manner, then create a virtual sleep controller
(similar to an interrupt nexus, except that defining a standardized
sleep-map should wait until its necessity is demonstrated).


IX - Specifying dma bus information

Some devices may have DMA memory range shifted relatively to the beginning of
RAM, or even placed outside of kernel RAM. For example, the Keystone 2 SoC
worked in LPAE mode with 4G memory has:
- RAM range: [0x8 0000 0000, 0x8 FFFF FFFF]
- DMA range: [  0x8000 0000,   0xFFFF FFFF]
and DMA range is aliased into first 2G of RAM in HW.

In such cases, DMA addresses translation should be performed between CPU phys
and DMA addresses. The "dma-ranges" property is intended to be used
for describing the configuration of such system in DT.

In addition, each DMA master device on the DMA bus may or may not support
coherent DMA operations. The "dma-coherent" property is intended to be used
for identifying devices supported coherent DMA operations in DT.

* DMA Bus master
Optional property:
- dma-ranges: <prop-encoded-array> encoded as arbitrary number of triplets of
	(child-bus-address, parent-bus-address, length). Each triplet specified
	describes a contiguous DMA address range.
	The dma-ranges property is used to describe the direct memory access (DMA)
	structure of a memory-mapped bus whose device tree parent can be accessed
	from DMA operations originating from the bus. It provides a means of
	defining a mapping or translation between the physical address space of
	the bus and the physical address space of the parent of the bus.
	(for more information see the Devicetree Specification)

* DMA Bus child
Optional property:
- dma-ranges: <empty> value. if present - It means that DMA addresses
	translation has to be enabled for this device.
- dma-coherent: Present if dma operations are coherent
